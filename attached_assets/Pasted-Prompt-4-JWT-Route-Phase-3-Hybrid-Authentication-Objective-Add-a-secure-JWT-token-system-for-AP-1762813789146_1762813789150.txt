Promptâ€¯4â€¯â€“â€¯JWTâ€¯Routeâ€¯(Phaseâ€¯3â€¯Hybridâ€¯Authentication)
Objective:
Add a secureâ€¯JWT token system for API / mobile access while keeping the existing sessionâ€‘based web authentication entirely intact.
Enable users to maintain traditional session login on web, but allow mobile clients (ToyPetMeâ€¯App) to authenticate using shortâ€‘lived JSONâ€¯Webâ€¯Tokens.

ğŸ”§ Implementationâ€¯Requirements
1ï¸âƒ£ Environmentâ€¯Variables
Add to your Replitâ€¯Secretsâ€¯/â€¯.envâ€¯file:

JWT_SECRET=<generateâ€¯strongâ€¯randomâ€¯key>
JWT_EXPIRATION=15m        # adjustable (15â€¯minutes recommended)
JWT_REFRESH_EXPIRATION=7d # for optional refresh tokens
2ï¸âƒ£ Dependencies
If not already present:

bash
Copy
npm install jsonwebtoken
3ï¸âƒ£ New Route: /api/token
Create an APIâ€¯endpoint that issues JWTs only for authenticated (sessionâ€‘holding) users.

js
Copy
import jwt from "jsonwebtoken";
import { verifySession } from "./middleware/sessionAuth.js";

app.get("/api/token", verifySession, (req, res) => {
  const user = req.session.user;

  // Payload includes minimal info only
  const payload = {
    id: user.id,
    email: user.email,
    verified: user.verified,
  };

  const token = jwt.sign(payload, process.env.JWT_SECRET, {
    expiresIn: process.env.JWT_EXPIRATION || "15m",
  });

  res.json({ token, expiresIn: process.env.JWT_EXPIRATION });
});
verifySession checks that the userâ€™s session cookie is valid.
This protects against anyone generating tokens without being logged in.
4ï¸âƒ£ Verifyâ€¯JWTâ€¯Middleware
Create a small middleware for mobile / API routes.

js
Copy
export function verifyJWT(req, res, next) {
  const authHeader = req.headers.authorization;
  if (!authHeader)
    return res.status(401).json({ error: "Missingâ€¯Authorizationâ€¯header" });

  const token = authHeader.split(" ")[1];
  jwt.verify(token, process.env.JWT_SECRET, (err, decoded) => {
    if (err) return res.status(403).json({ error: "Invalidâ€¯orâ€¯expiredâ€¯token" });
    req.user = decoded; // attach userâ€¯info
    next();
  });
}
Use on API routes that the mobile app accesses:

js
Copy
app.get("/api/pets", verifyJWT, (req, res) => {
  // Return pet data belonging to req.user.id
});
5ï¸âƒ£ Optionalâ€¯Refreshâ€¯Tokenâ€¯Flow
If you want your mobile app to avoid frequent reâ€‘logins:

js
Copy
app.post("/api/token/refresh", (req, res) => {
  const { token } = req.body;
  try {
    const { id, email } = jwt.verify(token, process.env.JWT_SECRET, { ignoreExpiration: true });
    const newToken = jwt.sign({ id, email }, process.env.JWT_SECRET, { expiresIn: "15m" });
    res.json({ token: newToken });
  } catch {
    res.status(401).json({ error: "Invalid refresh token" });
  }
});
6ï¸âƒ£ Mobileâ€¯Appâ€¯Usage
When your ToyPetMeâ€¯mobileâ€¯app logs in:

Call the /api/token endpoint (with credentials or by reusing a verified session link/QR).
Store the returned JWT securely â€” use SecureStorage or Keychain.
Attach it to every APIâ€¯request:
Authorization: Bearer <token>
7ï¸âƒ£ Testing Checklist
âœ… /api/token issuesâ€¯JWT for logged-inâ€¯user
âœ… Validâ€¯JWT grants access to /api/pets
âœ… Expired JWT â†’ 403â€¯error
âœ… Logout/sessionâ€¯clear â†’ userâ€¯cannot get newâ€¯JWT
âœ… Attempted unauthorizedâ€¯call â†’ 401â€¯error

ğŸ§¡ Whyâ€¯Thisâ€¯Matters
Benefit	Impact
Mobileâ€¯sync	Your Flutterâ€¯/â€¯Reactâ€¯Nativeâ€¯ToyPetMeâ€¯app can sync pets and progress securely.
Separationâ€¯ofâ€¯concerns	Keeps tight browser security while giving tokenâ€‘based APIâ€¯auth.
Scalability	Ready for external API integrations and pushâ€¯notifications.
Standardsâ€¯compliance	Uses modern, shortâ€‘lived JWTs with minimal payload (safe for GDPR/compliance)
ğŸ’¾ Deliverables
/api/token path implemented
verifyJWT middleware available for APIâ€¯routes
Secure JWT_SECRET configured
Test script demonstrating issuing and verifying tokens
Paste this Promptâ€¯4 directly in Replit AI or codebase tasks to implement securely.
After execution, your ToyPetMeâ€¯Authâ€¯System will be complete:

ğŸ§ â€¯Sessionsâ€¯forâ€¯webâ€¯+â€¯JWTâ€¯forâ€¯API/mobileâ€¯=â€¯Hybridâ€¯Authenticationâ€¯âœ…